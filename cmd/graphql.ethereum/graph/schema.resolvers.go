package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log/slog"
	"math"
	"math/big"
	"strconv"
	"strings"
	"time"

	ethCommon "github.com/ethereum/go-ethereum/common"
	"github.com/fluidity-money/9lives.so/cmd/graphql.ethereum/graph/model"
	"github.com/fluidity-money/9lives.so/lib/ai"
	"github.com/fluidity-money/9lives.so/lib/crypto"
	"github.com/fluidity-money/9lives.so/lib/features"
	"github.com/fluidity-money/9lives.so/lib/setup"
	"github.com/fluidity-money/9lives.so/lib/types"
	"github.com/fluidity-money/9lives.so/lib/types/banners"
	"github.com/fluidity-money/9lives.so/lib/types/changelog"
	commitment_reveal "github.com/fluidity-money/9lives.so/lib/types/commitment-reveal"
	"github.com/fluidity-money/9lives.so/lib/types/events"
	"github.com/fluidity-money/9lives.so/lib/types/paymaster"
	"github.com/fluidity-money/9lives.so/lib/types/referrer"
	"github.com/fluidity-money/9lives.so/lib/webhooks"
	"github.com/lib/pq"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

// OutcomeName is the resolver for the outcomeName field.
func (r *activityResolver) OutcomeName(ctx context.Context, obj *types.Activity) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("activity is nil")
	}
	outcomes := obj.CampaignContent.Outcomes
	outcomeMap := make(map[string]types.Outcome, len(outcomes))
	for _, _outcome := range outcomes {
		outcomeMap[_outcome.Identifier] = _outcome
	}
	if outcome, found := outcomeMap["0x"+obj.OutcomeID]; found {
		return outcome.Name, nil
	}
	return "", nil
}

// OutcomePic is the resolver for the outcomePic field.
func (r *activityResolver) OutcomePic(ctx context.Context, obj *types.Activity) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("activity is nil")
	}
	outcomes := obj.CampaignContent.Outcomes
	outcomeMap := make(map[string]types.Outcome, len(outcomes))
	for _, _outcome := range outcomes {
		outcomeMap[_outcome.Identifier] = _outcome
	}
	if outcome, found := outcomeMap["0x"+obj.OutcomeID]; found {
		return outcome.Picture, nil
	}
	return nil, nil
}

// CampaignName is the resolver for the campaignName field.
func (r *activityResolver) CampaignName(ctx context.Context, obj *types.Activity) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("activity is nil")
	}
	return obj.CampaignContent.Name, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *activityResolver) CreatedAt(ctx context.Context, obj *types.Activity) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("activity is nil")
	}
	return int(obj.CreatedAt.Unix()), nil
}

// CampaignContent is the resolver for the campaignContent field.
func (r *activityResolver) CampaignContent(ctx context.Context, obj *types.Activity) (*types.Campaign, error) {
	var campaign types.Campaign
	if obj == nil {
		return nil, fmt.Errorf("Activity is nil")
	}
	campaign = types.Campaign{
		ID:        obj.CampaignID,
		Content:   obj.CampaignContent,
		CreatedAt: time.Unix(int64(obj.CampaignContent.Starting), 0),
		UpdatedAt: time.Unix(int64(obj.CampaignContent.Starting), 0),
	}
	return &campaign, nil
}

// Name is the resolver for the name field.
func (r *campaignResolver) Name(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.Name, nil
}

// Description is the resolver for the description field.
func (r *campaignResolver) Description(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.Description, nil
}

// Picture is the resolver for the picture field.
func (r *campaignResolver) Picture(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Picture, nil
}

// Creator is the resolver for the creator field.
func (r *campaignResolver) Creator(ctx context.Context, obj *types.Campaign) (*types.Wallet, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Creator, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *campaignResolver) CreatedAt(ctx context.Context, obj *types.Campaign) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("campaign is nil")
	}
	return int(obj.CreatedAt.Unix()), nil
}

// Settlement is the resolver for the settlement field.
func (r *campaignResolver) Settlement(ctx context.Context, obj *types.Campaign) (model.SettlementType, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return model.SettlementType(obj.Content.Settlement), nil
}

// OracleDescription is the resolver for the oracleDescription field.
func (r *campaignResolver) OracleDescription(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.OracleDescription, nil
}

// OracleUrls is the resolver for the oracleUrls field.
func (r *campaignResolver) OracleUrls(ctx context.Context, obj *types.Campaign) ([]*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.OracleUrls, nil
}

// Identifier is the resolver for the identifier field.
func (r *campaignResolver) Identifier(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.ID, nil
}

// PoolAddress is the resolver for the poolAddress field.
func (r *campaignResolver) PoolAddress(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.PoolAddress, nil
}

// Outcomes is the resolver for the outcomes field.
func (r *campaignResolver) Outcomes(ctx context.Context, obj *types.Campaign) ([]types.Outcome, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Outcomes, nil
}

// Starting is the resolver for the starting field.
func (r *campaignResolver) Starting(ctx context.Context, obj *types.Campaign) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Starting, nil
}

// Ending is the resolver for the ending field.
func (r *campaignResolver) Ending(ctx context.Context, obj *types.Campaign) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Ending, nil
}

// X is the resolver for the x field.
func (r *campaignResolver) X(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.X, nil
}

// Telegram is the resolver for the telegram field.
func (r *campaignResolver) Telegram(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Telegram, nil
}

// Web is the resolver for the web field.
func (r *campaignResolver) Web(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Web, nil
}

// Winner is the resolver for the winner field.
func (r *campaignResolver) Winner(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Winner, nil
}

// InvestmentAmounts is the resolver for the investmentAmounts field.
func (r *campaignResolver) InvestmentAmounts(ctx context.Context, obj *types.Campaign) ([]*types.InvestmentAmounts, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.InvestmentAmounts, nil
}

// Banners is the resolver for the banners field.
func (r *campaignResolver) Banners(ctx context.Context, obj *types.Campaign) ([]string, error) {
	if obj == nil {
		return nil, fmt.Errorf("empty campaign")
	}
	var b []banners.Banner
	err := r.DB.Table("ninelives_banners_1").
		Where("pool = ?", obj.ID).
		Find(&b).
		Error
	if err != nil {
		slog.Error("Failed to find banners",
			"pool", obj.ID,
			"err", err,
		)
		return nil, fmt.Errorf("find banners: %v", err)
	}
	msgs := make([]string, len(b))
	for i := 0; i < len(b); i++ {
		msgs[i] = b[i].Message
	}
	return msgs, nil
}

// Categories is the resolver for the categories field.
func (r *campaignResolver) Categories(ctx context.Context, obj *types.Campaign) ([]string, error) {
	if obj == nil {
		return nil, fmt.Errorf("empty changelog")
	}
	return obj.Content.Categories, nil
}

// IsDpm is the resolver for the isDpm field.
func (r *campaignResolver) IsDpm(ctx context.Context, obj *types.Campaign) (*bool, error) {
	if obj == nil {
		return nil, fmt.Errorf("empty campaign")
	}
	return obj.Content.IsDpm, nil
}

// IsDppm is the resolver for the isDppm field.
func (r *campaignResolver) IsDppm(ctx context.Context, obj *types.Campaign) (bool, error) {
	if obj == nil {
		return false, fmt.Errorf("empty campaign")
	}
	isDppm := obj.Content.IsDppm != nil && *obj.Content.IsDppm
	return isDppm, nil
}

// Shares is the resolver for the shares field.
func (r *campaignResolver) Shares(ctx context.Context, obj *types.Campaign) ([]*types.CampaignShare, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Shares, nil
}

// PriceMetadata is the resolver for the priceMetadata field.
func (r *campaignResolver) PriceMetadata(ctx context.Context, obj *types.Campaign) (*types.PriceMetadata, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.PriceMetadata, nil
}

// ID is the resolver for the id field.
func (r *changelogResolver) ID(ctx context.Context, obj *changelog.Changelog) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty changelog")
	}
	return fmt.Sprintf("%v-%v", obj.Time, obj.Title), nil
}

// AfterTs is the resolver for the afterTs field.
func (r *changelogResolver) AfterTs(ctx context.Context, obj *changelog.Changelog) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("empty changelog")
	}
	return int(obj.Time.Unix()), nil
}

// HTML is the resolver for the html field.
func (r *changelogResolver) HTML(ctx context.Context, obj *changelog.Changelog) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty changelog")
	}
	return obj.HtmlContent, nil
}

// Content is the resolver for the content field.
func (r *claimResolver) Content(ctx context.Context, obj *types.Claim) (*types.Campaign, error) {
	var campaign types.Campaign
	if obj == nil {
		return nil, fmt.Errorf("Claim is nil")
	}
	campaign = types.Campaign{
		ID:        obj.ID,
		Content:   obj.Content,
		CreatedAt: time.Unix(int64(obj.Content.Starting), 0),
		UpdatedAt: time.Unix(int64(obj.Content.Starting), 0),
	}
	return &campaign, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *claimResolver) CreatedAt(ctx context.Context, obj *types.Claim) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("claim is nil")
	}
	return int(obj.CreatedAt.Unix()), nil
}

// TxHash is the resolver for the txHash field.
func (r *claimResolver) TxHash(ctx context.Context, obj *types.Claim) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("claim is nil")
	}
	return obj.TransactionHash, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *commentResolver) CreatedAt(ctx context.Context, obj *types.Comment) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("Comment is nil")
	}
	return int(obj.CreatedAt.Unix()), nil
}

// Investments is the resolver for the investments field.
func (r *commentResolver) Investments(ctx context.Context, obj *types.Comment) ([]*types.CommentInvestment, error) {
	if obj == nil {
		return nil, fmt.Errorf("comment is nil")
	}
	return obj.Investments, nil
}

// PostComment is the resolver for the postComment field.
func (r *mutationResolver) PostComment(ctx context.Context, campaignID string, walletAddress string, content string, rr string, s string, v int) (*bool, error) {
	if !ethCommon.IsHexAddress(walletAddress) {
		return nil, fmt.Errorf("bad wallet address")
	}
	sender := strings.ToLower(walletAddress)
	senderAddr := ethCommon.HexToAddress(sender)
	_, err := validateCommentSig(senderAddr, content, campaignID, "post", rr, s, v)
	if err != nil {
		return nil, fmt.Errorf("signature is not valid")
	}
	comment := types.CommentInput{
		CampaignId:    campaignID,
		WalletAddress: sender,
		Content:       content,
	}
	err = r.DB.Table("ninelives_comments_1").Create(&comment).Error
	if err != nil {
		return nil, fmt.Errorf("Error to post comment")
	}
	var res = true
	return &res, nil
}

// DeleteComment is the resolver for the deleteComment field.
func (r *mutationResolver) DeleteComment(ctx context.Context, campaignID string, id int, walletAddress string, content string, rr string, s string, v int) (*bool, error) {
	if !ethCommon.IsHexAddress(walletAddress) {
		return nil, fmt.Errorf("bad wallet address")
	}
	sender := strings.ToLower(walletAddress)
	senderAddr := ethCommon.HexToAddress(sender)
	_, err := validateCommentSig(senderAddr, content, campaignID, "delete", rr, s, v)
	if err != nil {
		return nil, fmt.Errorf("signature is not valid")
	}
	comment := types.Comment{
		Id:         id,
		CampaignId: campaignID,
	}
	err = r.DB.Table("ninelives_comments_1").Select("*").Where(&comment).First(&comment).Error
	if err != nil {
		return nil, fmt.Errorf("error getting comment")
	}
	if comment.WalletAddress != sender {
		return nil, fmt.Errorf("wallet is not owner")
	}
	err = r.DB.Table("ninelives_comments_1").Delete(&comment).Error
	if err != nil {
		return nil, fmt.Errorf("error to delete comment")
	}
	var res = true
	return &res, nil
}

// RequestPaymaster is the resolver for the requestPaymaster field.
func (r *mutationResolver) RequestPaymaster(ctx context.Context, ticket *int, typeArg model.Modification, nonce string, deadline int, permitAmount string, permitV int, permitR string, permitS string, operation model.PaymasterOperation, owner string, outcome *string, referrer *string, market string, maximumFee string, amountToSpend string, minimumBack string, originatingChainID string, outgoingChainEid int, rr string, s string, v int) (*string, error) {
	// Verify the user has the amount to spend that they're requesting.
	if r.F.Is(features.FeatureShouldCheckErc20Balance) {
		panic("unimplemented")
	}
	// Check their nonce is the latest.
	if r.F.Is(features.FeatureShouldCheckPaymasterNonce) {
		panic("unimplemented")
	}
	// Check that the market exists according to our internal database.
	if r.F.Is(features.FeatureShouldValidateMarketExistence) {
		panic("unimplemented")
	}
	var typ uint8
	switch operation {
	case model.PaymasterOperationMint:
		typ = paymaster.PaymasterTypeMint
	case model.PaymasterOperationSell:
		typ = paymaster.PaymasterTypeBurn
	case model.PaymasterOperationAddLiquidity:
		typ = paymaster.PaymasterTypeAddLiquidity
	case model.PaymasterOperationRemoveLiquidity:
		typ = paymaster.PaymasterTypeRemoveLiquidity
	case model.PaymasterOperationWithdrawUsdc:
		typ = paymaster.PaymasterTypeWithdrawUsdc
	default:
		return nil, fmt.Errorf("bad type")
	}
	p := paymaster.Poll{
		Deadline: deadline,
		Typ:      typ,
	}
	nonce_, err := events.NumberFromString(nonce)
	if err != nil {
		return nil, fmt.Errorf("nonce")
	}
	p.Nonce = *nonce_
	owner_, err := events.MaybeAddressFromString(owner)
	if err != nil {
		return nil, fmt.Errorf("owner")
	}
	p.Owner = *owner_
	if permitR != "" {
		permitR_, err := events.BytesFromHex(permitR)
		if err != nil {
			return nil, fmt.Errorf("permitr")
		}
		p.PermitR = sql.NullString{permitR_.String(), true}
	}
	if permitS != "" {
		permitS_, err := events.BytesFromHex(permitS)
		if err != nil {
			return nil, fmt.Errorf("permits")
		}
		p.PermitS = sql.NullString{permitS_.String(), true}
	}
	if permitV > math.MaxUint8 && permitV < 0 {
		return nil, fmt.Errorf("permit v value")
	}
	p.PermitV = uint8(permitV)
	if outgoingChainEid < 0 {
		return nil, fmt.Errorf("outgoing chain eid bad")
	}
	p.OutgoingChainEid = uint32(outgoingChainEid)
	market_, err := events.MaybeAddressFromString(market)
	if err != nil {
		return nil, fmt.Errorf("market")
	}
	p.Market = *market_
	maximumFee_, err := events.NumberFromString(maximumFee)
	if err != nil {
		return nil, fmt.Errorf("maximum fee")
	}
	p.MaximumFee = *maximumFee_
	// Check that the maximum fee is above the limit, or estimate the
	// cost if we have the feature enabled.
	if r.F.Is(features.FeatureShouldPriceCalldata) {
		panic("unimplemented")
	} else if r.PaymasterMinimumUSDCGas.Cmp(maximumFee_.Big()) < 0 {
		return nil, fmt.Errorf("too low maximum fee")
	}
	amountToSpend_, err := events.NumberFromString(amountToSpend)
	if err != nil {
		return nil, fmt.Errorf("amount to spend")
	}
	p.AmountToSpend = *amountToSpend_
	minimumBack_, err := events.NumberFromString(minimumBack)
	if err != nil {
		return nil, fmt.Errorf("minimum back")
	}
	p.MinimumBack = *minimumBack_
	rr_, err := events.BytesFromHex(rr)
	if err != nil {
		return nil, fmt.Errorf("r value")
	}
	permitAmt, err := events.NumberFromString(permitAmount)
	if err != nil {
		return nil, fmt.Errorf("permit amount")
	}
	p.PermitAmount = permitAmt
	p.R = *rr_
	s_, err := events.BytesFromHex(s)
	if err != nil {
		return nil, fmt.Errorf("s value")
	}
	p.S = *s_
	if v > math.MaxUint8 && v < 0 {
		return nil, fmt.Errorf("v value")
	}
	p.V = uint8(v)
	if referrer != nil {
		referrer_, err := events.MaybeAddressFromString(*referrer)
		if err != nil {
			return nil, fmt.Errorf("referrer")
		}
		p.Referrer = referrer_
	}
	if outcome != nil {
		outcome_, err := events.BytesFromHex(*outcome)
		if err != nil {
			return nil, fmt.Errorf("outcome")
		}
		p.Outcome = outcome_
	}
	spnChainId := new(big.Int).SetInt64(int64(r.C.ChainId))
	originatingChainId, ok := new(big.Int).SetString(originatingChainID, 10)
	if !ok {
		return nil, fmt.Errorf("chain id")
	}
	p.OriginatingChainId = events.NumberFromBig(originatingChainId)
	// Validate their signature.
	if r.F.Is(features.FeatureShouldValidatePaymasterSig) {
		owner, err := crypto.EcrecoverPaymasterOperation(
			spnChainId,
			originatingChainId,
			r.PaymasterAddr,
			crypto.PollToPaymasterOperation(p),
		)
		if err != nil {
			slog.Error("Error verifying a signature", "op", p, "err", err)
			return nil, fmt.Errorf("signature error")
		}
		a := ethCommon.HexToAddress(p.Owner.String())
		if !bytes.Equal(owner.Bytes(), a.Bytes()) {
			slog.Error("Supplied signature different",
				"owner", owner,
				"other address", a,
				"err", err,
			)
			return nil, fmt.Errorf("owner addr")
		}
	}
	if r.F.Is(features.FeatureShouldSimulateSubmission) {
		ok, cd, err := simPaymasterMulticall(
			ctx,
			r.Geth,
			r.PaymasterSenderAddr,
			r.PaymasterAddr,
			p,
		)
		if err != nil {
			slog.Error("Failed to simulate a paymaster multicall transaction",
				"p", p,
				"cd", hex.EncodeToString(cd),
				"err", err,
			)
			var actionDesc string
			switch p.Typ {
			case paymaster.PaymasterTypeMint:
				actionDesc = "mint"
			case paymaster.PaymasterTypeBurn:
				actionDesc = "burn"
			case paymaster.PaymasterTypeAddLiquidity:
				actionDesc = "add liquidity"
			case paymaster.PaymasterTypeRemoveLiquidity:
				actionDesc = "remove liquidity"
			case paymaster.PaymasterTypeWithdrawUsdc:
				actionDesc = "withdraw usdc"
			}
			err = r.F.On(features.FeatureShouldReportPaymasterFailure,
				r.C.W.TwistCur(
					IntentBadOperation,
					"Paymaster simulation was in error for a user",
					[]webhooks.F{
						{"Content", p},
						{"Paymaster address", r.PaymasterAddr},
						{"Sender", p.Owner},
						{"Amount", p.AmountToSpend},
						{"Market", p.Market},
						{"Type", actionDesc},
						{"Calldata", cd},
						{"Originating chain id", p.OriginatingChainId},
						{"Error", err},
						{"Error calldata", cd},
						{"Permit amount", permitAmt},
						{"Permit R", permitR},
						{"Permit S", permitS},
						{"Permit V", permitV},
						{"Deadline", deadline},
						{"Maximum fee", p.MaximumFee},
						{"Referrer", p.Referrer},
						{"Outgoing chain eid", p.OutgoingChainEid},
					},
				),
			)
			if err != nil {
				setup.Exitf("Failed to send Twist report about failure: %v", err)
			}
			return nil, fmt.Errorf("simulate paymaster send")
		}
		if !ok {
			slog.Error("Paymaster simulation returned false",
				"p", p,
				"cd", hex.EncodeToString(cd),
			)
			err = r.F.On(features.FeatureShouldReportPaymasterFailure,
				r.C.W.TwistCur(
					IntentBadOperation,
					"Paymaster simulation was false for a user",
					[]webhooks.F{
						{"Content", p},
						{"Paymaster address", r.PaymasterAddr},
						{"Sender", p.Owner},
						{"Calldata", cd},
					},
				),
			)
			if err != nil {
				setup.Exitf("Failed to send Twist report about failure: %v", err)
			}
			return nil, fmt.Errorf("paymaster simulation returned false")
		}
	}
	if err := r.DB.Table("ninelives_paymaster_poll_1").Create(&p).Error; err != nil {
		slog.Error("Error inserting new paymaster operation", "err", err)
		return nil, fmt.Errorf("insert paymaster op")
	}
	id := strconv.Itoa(p.ID)
	return &id, nil
}

// ExplainCampaign is the resolver for the explainCampaign field.
func (r *mutationResolver) ExplainCampaign(ctx context.Context, typeArg model.Modification, name string, description string, picture *string, seed int, outcomes []model.OutcomeInput, ending int, starting int, creator string, oracleDescription *string, oracleUrls []*string, x *string, telegram *string, web *string, isFake *bool, isDppm bool, categories []string, priceMetadata *model.PriceMetadataInput) (*bool, error) {
	isNotPrecommit := isFake == nil || !*isFake
	adminSecret, _ := ctx.Value("admin secret").(string)
	hasValidAdminSecret := adminSecret == r.AdminSecret
	outcomes_ := make([]crypto.Outcome, len(outcomes))
	if seed < 0 {
		return nil, fmt.Errorf("negative seed")
	}
	curTime := int(time.Now().Unix())
	if curTime >= ending {
		return nil, fmt.Errorf("ending time too early")
	}
	for i, o := range outcomes {
		outcomes_[i] = crypto.Outcome{
			Name: o.Name,
			Seed: uint64(o.Seed),
		}
	}
	marketId := crypto.GetMarketId(outcomes_)
	zeroAddr := ethCommon.HexToAddress("0x0000000000000000000000000000000000000000")
	var (
		tradingAddr *ethCommon.Address = &zeroAddr
		settlement  string             = "ORACLE"
		err         error
	)
	if isDppm && r.F.Is(features.FeatureDppmMarketsMustBeMadeByAdmin) {
		if !hasValidAdminSecret {
			return nil, fmt.Errorf("bad admin secret for dppm creation")
		}
	}
	if isNotPrecommit {
		tradingAddr, err = getTradingAddr(r.Geth, r.FactoryAddr, marketId)
		if err != nil {
			slog.Error("Error checking if trading contract is deployed",
				"trading contract", tradingAddr,
				"factory address", r.FactoryAddr,
				"market id", marketId,
				"error", err,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf("error checking if trading contract is deployed")
		}
		settlement, err = getSettlementTypeDesc(
			r.Geth,
			r.InfraMarketAddr,
			r.BeautyContestAddr,
			r.SarpAiAddr,
			r.PriceResolverAddr,
			*tradingAddr,
		)
		if err != nil {
			slog.Error("Failed to get the settlement type description",
				"trading contract", tradingAddr,
				"factory address", r.FactoryAddr,
				"market id", marketId,
				"error", err,
			)
			return nil, fmt.Errorf("error retrieving oracle type")
		}
	}
	if settlement == "PRICE_ORACLE" && !isDppm {
		return nil, fmt.Errorf("DPPM only for price oracle markets")
	}
	err = r.F.On(features.FeatureUseAiForCheckingIfCampaignMakesSense, func() error {
		_, err = ai.RequestFromAi(
			r.LambdaClient,
			ctx,
			r.LambdaMiscAiBackendName,
			"is legit",
			name,
		)
		if err != nil {
			slog.Error("Failed to look up a request for if a campaign is legit",
				"name", name,
				"err", err,
			)
			return fmt.Errorf("failed to look up request: %v", err)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	// Create the campaign object
	campaignId, _ := crypto.GetCampaignId(name, description, uint64(seed))
	hexCampaignId := "0x" + hex.EncodeToString(campaignId)
	var tradingAddrStr, contractOwner string
	if isNotPrecommit {
		contractOwner_, err := getOwner(r.Geth, r.FactoryAddr, *tradingAddr)
		if err != nil {
			slog.Error("Error checking if trading contract is deployed",
				"trading contract", tradingAddr,
				"factory address", r.FactoryAddr,
				"market id", marketId,
				"error", err,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf("error checking if trading contract is deployed")
		}
		creator = strings.ToLower(creator)
		tradingAddrStr = strings.ToLower(tradingAddr.Hex())
		contractOwner = strings.ToLower(contractOwner_.Hex())
		if contractOwner != creator {
			slog.Error("Staged creator is not the contract owner",
				"trading contract", tradingAddr,
				"contractOwner", contractOwner,
				"factory address", r.FactoryAddr,
				"market id", marketId,
				"submitted creator", creator,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf(
				"staged creator is not the contract owner for id %x, owner is %v",
				marketId,
				contractOwner,
			)
		}
		var campaignIdCount int64
		err = r.DB.Table("ninelives_campaigns_1").
			Where("id = ?", hexCampaignId).
			Count(&campaignIdCount).
			Error
		if err != nil {
			slog.Error("Error checking the existence of this trading addr",
				"trading contract", tradingAddr,
				"factory address", r.FactoryAddr,
				"market id", marketId,
				"error", err,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf("error finding trading addr existence")
		}
		if campaignIdCount > 0 {
			return nil, fmt.Errorf("trading addr already exists")
		}
	}
	// Create outcomes object
	var campaignOutcomes = make([]types.Outcome, len(outcomes))
	for i, outcome := range outcomes {
		outcomeId, _ := crypto.GetOutcomeId(
			outcome.Name,
			uint64(outcome.Seed),
		)
		hexOutcomeId := "0x" + hex.EncodeToString(outcomeId)
		var shareAddrStr string
		if isNotPrecommit {
			shareAddr, _ := getShareAddr(r.Geth, *tradingAddr, [8]byte(outcomeId))
			shareAddrStr = strings.ToLower(shareAddr.Hex())
		}
		var outcomePicUrl *string
		if pic := outcome.Picture; pic != nil && *pic != "" {
			var img string
			picKey := fmt.Sprintf("%v-%v", tradingAddr, shareAddrStr)
			img, err = uploadTradingPicMaybePrecommit(
				ctx,
				r.S3UploadBucketName,
				r.PicturesUriBase,
				r.S3UploadManager,
				*pic,
				picKey,
				isNotPrecommit,
			)
			if err != nil {
				slog.Error("Failed to work with a image",
					"trading addr", tradingAddr,
					"creator", creator,
					"err", err,
					"is not precommit", isNotPrecommit,
				)
				return nil, fmt.Errorf("image server error")
			}
			outcomePicUrl = &img
		}
		campaignOutcomes[i] = types.Outcome{
			Name:       outcome.Name,
			Picture:    outcomePicUrl,
			Seed:       outcome.Seed,
			Identifier: hexOutcomeId,
			Share: &types.Share{
				Address: shareAddrStr,
			},
		}
	}
	var tradingPicUrl *string
	if picture != nil {
		var img string
		img, err = uploadTradingPicMaybePrecommit(
			ctx,
			r.S3UploadBucketName,
			r.PicturesUriBase,
			r.S3UploadManager,
			*picture,
			tradingAddrStr,
			isNotPrecommit,
		)
		if err != nil {
			slog.Error("Failed to work with a image",
				"trading addr", tradingAddr,
				"creator", creator,
				"err", err,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf("image server error")
		}
		tradingPicUrl = &img
	}
	if categories != nil {
		err = r.F.On(features.FeatureCategoryOverridesShouldBeMadeByAdmin, func() error {
			if !hasValidAdminSecret {
				return fmt.Errorf("invalid secret for category override")
			}
			return nil
		})
		if err != nil {
			return nil, fmt.Errorf("bad feature use for category override: %v", err)
		}
	} else {
		err = r.F.On(features.FeatureUseAIForCategories, func() error {
			categories, err = ai.RequestFromAi(
				r.LambdaClient,
				ctx,
				r.LambdaMiscAiBackendName,
				"categories",
				name,
			)
			if err != nil {
				slog.Error("Failed to look up a request for categories",
					"name", name,
					"err", err,
				)
				return fmt.Errorf("failed to look up request: %v", err)
			}
			return nil
		})
		if err != nil {
			return nil, fmt.Errorf("bad feature use for ai: %v", err)
		}
	}
	var priceMetadataField *types.PriceMetadata
	if priceMetadata != nil {
		if !hasValidAdminSecret {
			return nil, fmt.Errorf("bad admin secret for price metadata field")
		}
		priceMetadataField = &types.PriceMetadata{
			BaseAsset:        priceMetadata.BaseAsset,
			QuoteAsset:       priceMetadata.QuoteAsset,
			PriceTargetForUp: priceMetadata.PriceTargetForUp,
		}
	}
	campaign := types.CampaignInsertion{
		ID: hexCampaignId,
		Content: types.CampaignContent{
			Name:        name,
			Description: description,
			Picture:     tradingPicUrl,
			Categories:  categories,
			Seed:        seed,
			Creator: &types.Wallet{
				Address: creator,
			},
			Settlement:        string(settlement),
			OracleDescription: oracleDescription,
			OracleUrls:        oracleUrls,
			PoolAddress:       tradingAddrStr,
			Outcomes:          campaignOutcomes,
			Ending:            ending,
			Starting:          starting,
			X:                 x,
			Telegram:          telegram,
			Web:               web,
			IsDppm:            &isDppm,
			PriceMetadata:     priceMetadataField,
		},
	}
	if isNotPrecommit {
		err = r.DB.Table("ninelives_campaigns_1").Create(&campaign).Error
		if err != nil {
			slog.Error("Error inserting campaign into database",
				"error", err,
				"is not precommit", isNotPrecommit,
			)
			return nil, fmt.Errorf("error inserting campaign into database")
		}
	} else {
		stmt := r.DB.Session(&gorm.Session{DryRun: true}).
			Table("ninelives_campaigns_1").
			Create(&campaign).
			Statement
		s := r.DB.Dialector.Explain(stmt.SQL.String(), stmt.Vars...)
		if err := r.DB.Exec("EXPLAIN " + s).Error; err != nil {
			slog.Error("Error explaining a precommit",
				"error", err,
				"is not precommit", isNotPrecommit,
				"stmt", s,
			)
			return nil, fmt.Errorf("error with precommit")
		}
	}
	res := true
	return &res, nil
}

// RevealCommitment is the resolver for the revealCommitment field.
func (r *mutationResolver) RevealCommitment(ctx context.Context, tradingAddr string, sender string, seed string, preferredOutcome string) (*bool, error) {
	if tradingAddr == "" || sender == "" || seed == "" || preferredOutcome == "" {
		return nil, fmt.Errorf("field not set")
	}
	// Currently, since no-one's using this functionality, we're
	// being uber permissive with the insertion.
	tradingAddr_, err := events.MaybeAddressFromString(tradingAddr)
	if err != nil {
		slog.Error("Trading addr from string",
			"err", err,
			"trading addr", tradingAddr,
			"sender", sender,
			"seed", seed,
		)
		return nil, fmt.Errorf("trading addr from string")
	}
	sender_, err := events.MaybeAddressFromString(sender)
	if err != nil {
		slog.Error("Sender addr from string",
			"err", err,
			"trading addr", tradingAddr,
			"sender", sender,
			"seed", seed,
		)
		return nil, fmt.Errorf("sender addr from string")
	}
	seed_, ok := new(big.Int).SetString(seed, 10)
	if !ok {
		slog.Error("Seed conversion didn't happen",
			"err", err,
			"trading addr", tradingAddr,
			"sender", sender,
			"seed", seed,
		)
		return nil, fmt.Errorf("seed error converting")
	}
	preferredOutcome_, err := events.BytesFromHex(strings.TrimPrefix(preferredOutcome, "0x"))
	if err != nil {
		slog.Error("Bad preferred outcome bytes coercion",
			"err", err,
			"trading addr", tradingAddr,
			"sender", sender,
			"seed", seed,
		)
		return nil, fmt.Errorf("outcome bytes coercion")
	}
	err = r.DB.Table("ninelives_revealed_commitments_1").
		Create(&commitment_reveal.CommitmentReveal{
			TradingAddr:      *tradingAddr_,
			Sender:           *sender_,
			Seed:             events.NumberFromBig(seed_),
			PreferredOutcome: *preferredOutcome_,
		}).
		Error
	if err != nil {
		slog.Error("Failed to insert revealed commitment",
			"err", err,
			"trading addr", tradingAddr,
			"sender", sender,
			"seed", seed,
		)
		return nil, fmt.Errorf("insert campaign error")
	}
	y := true
	return &y, nil
}

// RevealCommitment2 is the resolver for the revealCommitment2 field.
func (r *mutationResolver) RevealCommitment2(ctx context.Context, tradingAddr string, sender string, seed string, preferredOutcome string, rr string, s string, v string) (*bool, error) {
	panic(fmt.Errorf("not implemented: RevealCommitment2 - revealCommitment2"))
}

// SynchProfile is the resolver for the synchProfile field.
func (r *mutationResolver) SynchProfile(ctx context.Context, walletAddress string, email string) (*bool, error) {
	var profile = types.Profile{
		WalletAddress: strings.ToLower(walletAddress),
		Email:         email,
		Settings: types.Settings{
			Notification: true,
		},
	}
	var res bool
	err := r.DB.Table("ninelives_users_1").Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "wallet_address"}},
		DoUpdates: clause.AssignmentColumns([]string{"email"}),
	}).Create(&profile).Error
	if err != nil {
		res = false
		slog.Error("Error synching profile",
			"wallet address", walletAddress,
			"email", email,
			"err", err,
		)
		return &res, fmt.Errorf("error synching profile")
	}
	res = true
	return &res, nil
}

// GenReferrer is the resolver for the genReferrer field.
func (r *mutationResolver) GenReferrer(ctx context.Context, walletAddress string, code string) (string, error) {
	if walletAddress == "" || code == "" {
		return "", fmt.Errorf("bad referrer or wallet")
	}
	if !ethCommon.IsHexAddress(walletAddress) {
		return "", fmt.Errorf("not wallet address")
	}
	walletAddress = strings.ToLower(walletAddress)
	ipAddr := ctx.Value("ip addr").(string)
	err := r.DB.Table("ninelives_referrer_1").Create(&referrer.Referrer{
		Owner:     walletAddress,
		CreatorIp: ipAddr,
		Code:      code,
	})
	if err := err.Error; err != nil {
		slog.Error("Failed to generate a referrer code from a user",
			"ip addr", ipAddr,
			"code", code,
			"owner", walletAddress,
			"error", err,
		)
		return "", fmt.Errorf("failed to generate code")
	}
	return code, nil
}

// AssociateReferral is the resolver for the associateReferral field.
func (r *mutationResolver) AssociateReferral(ctx context.Context, sender string, code string, rr string, s string, v int) (*bool, error) {
	if r.F.Is(features.FeatureReferrerNeedsToVerify) {
		panic("unimplemented")
	}
	if !ethCommon.IsHexAddress(sender) {
		return nil, fmt.Errorf("bad referrer associate")
	}
	sender = strings.ToLower(sender)
	senderAddr := ethCommon.HexToAddress(sender)
	var referrer string
	err := r.DB.Raw(
		"SELECT owner FROM ninelives_referrer_1 WHERE code = ?",
		code,
	).
		Scan(&referrer).Error
	if err != nil {
		slog.Error("Failed to find referrer",
			"code", code,
			"error", err,
		)
		return nil, fmt.Errorf("failed to scan referrer")
	}
	if referrer == "" {
		return nil, fmt.Errorf("referrer is empty")
	}
	referrerAddr := ethCommon.HexToAddress(referrer)
	if senderAddr == referrerAddr {
		return nil, fmt.Errorf("sender != referrer")
	}
	signer, err := validateReferralSig(senderAddr, referrerAddr, rr, s, v)
	if err != nil {
		slog.Error("Unable to validate referral sig",
			"error", err,
			"sender", sender,
			"r", rr,
			"s", s,
			"v", v,
			"signer", signer,
		)
		return nil, fmt.Errorf("unable to validate referral sig")
	}
	if signer != senderAddr {
		slog.Error("Different signer for signature",
			"signer", signer,
			"sender", sender,
		)
		return nil, fmt.Errorf("different signer for sig")
	}
	var profile = types.Profile{
		WalletAddress: strings.ToLower(sender),
		Email:         "",
		Settings: types.Settings{
			Notification: true,
			Referrer:     strings.ToLower(referrer),
		},
	}
	err = r.DB.Table("ninelives_users_1").Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "wallet_address"}},
		DoUpdates: clause.AssignmentColumns([]string{"settings"}),
	}).Create(&profile).Error
	if err != nil {
		slog.Error("Failed to update the referrer for a user",
			"error", err,
			"referrer", referrer,
			"sender", sender,
			"r", rr,
			"s", s,
			"v", v,
		)
		return nil, fmt.Errorf("update referrer for user")
	}
	t := true
	return &t, nil
}

// Content is the resolver for the content field.
func (r *positionResolver) Content(ctx context.Context, obj *types.Position) (*types.Campaign, error) {
	var campaign types.Campaign
	if obj == nil {
		return nil, fmt.Errorf("Position is nil")
	}
	campaign = types.Campaign{
		ID:        obj.CampaignId,
		Content:   obj.Content,
		CreatedAt: time.Unix(int64(obj.Content.Starting), 0),
		UpdatedAt: time.Unix(int64(obj.Content.Starting), 0),
	}
	return &campaign, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *priceEventResolver) CreatedAt(ctx context.Context, obj *types.PriceEvent) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("event is nil")
	}
	return int(obj.CreatedAt.Unix()), nil
}

// Shares is the resolver for the shares field.
func (r *priceEventResolver) Shares(ctx context.Context, obj *types.PriceEvent) ([]*types.CampaignShare, error) {
	if obj == nil {
		return nil, fmt.Errorf("event is nil")
	}
	return obj.Shares, nil
}

// Campaigns is the resolver for the campaigns field.
func (r *queryResolver) Campaigns(ctx context.Context, category []string, orderBy *string, searchTerm *string, page *int, pageSize *int, address *string) ([]types.Campaign, error) {
	var campaigns []types.Campaign
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		campaigns = MockGraphCampaigns()
		return campaigns, nil
	}
	selectClause := "nc.*,nead.shares AS shares,nmods.odds AS odds"
	fromClause := " FROM ninelives_campaigns_1 AS nc "
	joinClause := `LEFT JOIN (SELECT DISTINCT ON (emitter_addr) * FROM ninelives_events_amm_details ORDER BY emitter_addr, created_by DESC) AS nead on nead.emitter_addr = nc.content->>'poolAddress'
	LEFT JOIN (SELECT DISTINCT ON (pool_address) * FROM ninelives_market_odds_snapshot_1 ORDER BY pool_address, created_by DESC) AS nmods on nmods.pool_address = nc.content->>'poolAddress'
	`
	whereClause := "WHERE shown = TRUE"
	orderClause := ""
	args := []interface{}{}
	if address != nil {
		*address = strings.ToLower(*address)
		whereClause += " AND content->'creator'->>'address' = ?"
		args = append(args, *address)
	}
	if len(category) > 0 {
		jsonCategories, err := json.Marshal(category)
		if err != nil {
			return nil, fmt.Errorf("category filter can not be converted to json")
		}
		whereClause += " AND content->'categories' @> ?"
		args = append(args, string(jsonCategories))
	}
	if searchTerm != nil {
		whereClause += " AND name_to_search ILIKE ?"
		args = append(args, "%"+*searchTerm+"%")
	}

	if orderBy == nil {
		whereClause += " AND content->>'winner' IS NULL"
		orderClause = " ORDER BY total_volume DESC"
	} else if *orderBy == "ended" {
		selectClause += ",neo.created_by AS winner_decided_at"
		joinClause += " JOIN ninelives_events_outcome_decided AS neo ON neo.emitter_addr = nc.content->>'poolAddress'"
		orderClause = " ORDER BY winner_decided_at DESC"
	} else {
		whereClause += " AND content->>'winner' IS NULL"
		switch *orderBy {
		case "trending":
			fromClause = " FROM private_ninelives_campaigns_sorted_by_breakout_4 AS nc "
			orderClause = " ORDER BY breakout_score DESC"
		case "newest":
			orderClause = " ORDER BY created_at DESC"
		case "volume":
			orderClause = " ORDER BY total_volume DESC"
		case "ending":
			whereClause += " AND ( (content->>'ending')::bigint - EXTRACT(EPOCH FROM NOW()) ) > 0"
			orderClause = " ORDER BY ( (content->>'ending')::bigint - EXTRACT(EPOCH FROM NOW()) ) ASC"
		case "liquidity":
			selectClause += `,(
    COALESCE((SELECT SUM(fusdc_amt) FROM ninelives_events_liquidity_added nela WHERE emitter_addr = nc.content->>'poolAddress'), 0)
    -
    COALESCE((SELECT SUM(fusdc_amt) FROM ninelives_events_liquidity_removed nelr WHERE emitter_addr = nc.content->>'poolAddress'), 0)
) AS liquidity_vested`
			orderClause = " ORDER BY liquidity_vested DESC"
		default:
			return nil, fmt.Errorf("invalid orderBy value")
		}
	}
	pageNum := 0
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 8
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	paginationClause := ""
	if pageNum != -1 {
		paginationClause = fmt.Sprintf(" OFFSET %d LIMIT %d", pageNum*pageSizeNum, pageSizeNum)
	}
	finalQuery := "SELECT " + selectClause + fromClause + joinClause + whereClause + orderClause + paginationClause
	err := r.DB.Raw(finalQuery, args...).Scan(&campaigns).Error
	if err != nil {
		slog.Error("Error getting campaigns from database",
			"error", err,
		)
		return nil, fmt.Errorf("error getting campaigns from database: %w", err)
	}
	return campaigns, nil
}

// CampaignByID is the resolver for the campaignById field.
func (r *queryResolver) CampaignByID(ctx context.Context, id string) (*types.Campaign, error) {
	if id == "" || !strings.HasPrefix(id, "0x") {
		return nil, fmt.Errorf("bad id")
	}
	var c types.Campaign
	err := r.DB.Raw(`WITH summed_amounts AS (
    SELECT
        campaign_id,
        outcome_id,
        SUM(
        case when type = 'buy' THEN from_amount else -to_amount end
        ) AS sum_from_amount,
        SUM(
        case when type = 'buy' then to_amount else -from_amount end
        ) as sum_to_amount
    FROM
        ninelives_buys_and_sells_1
    WHERE
        campaign_id = ?
    GROUP BY
        campaign_id, outcome_id
),
campaign_investments AS (
    SELECT
        campaign_id,
        JSON_AGG(
            JSON_BUILD_OBJECT('id', CONCAT('0x', outcome_id), 'usdc', sum_from_amount, 'share', sum_to_amount)
        ) AS investment_amounts,
        SUM(summed_amounts.sum_from_amount) AS total_volume
    FROM
        summed_amounts
    GROUP BY
        campaign_id
)
SELECT
    	nc.*,
		ci.investment_amounts,
		(
    		COALESCE(
    		    (SELECT SUM(fusdc_amt)
    		     FROM ninelives_events_liquidity_added nela
    		     WHERE emitter_addr = nc.content->>'poolAddress'), 0
    		)
    		-
    		COALESCE(
    		    (SELECT SUM(fusdc_amt)
    		     FROM ninelives_events_liquidity_removed nelr
    		     WHERE emitter_addr = nc.content->>'poolAddress'), 0
    		)
		) AS liquidity_vested,
		nmods.odds
		FROM
			ninelives_campaigns_1 nc
		LEFT JOIN
        campaign_investments ci ON nc.id = ci.campaign_id
		LEFT JOIN (
		SELECT DISTINCT ON (pool_address) * FROM ninelives_market_odds_snapshot_1 ORDER BY pool_address, created_by DESC
		) AS nmods on nmods.pool_address = nc.content->>'poolAddress'
		WHERE
			nc.id = ? AND shown`, id, id).Scan(&c).Error
	if err != nil {
		return nil, fmt.Errorf("campaign find: %v", err)
	}
	return &c, nil
}

// SuggestedHeadlines is the resolver for the suggestedHeadlines field.
func (r *queryResolver) SuggestedHeadlines(ctx context.Context) ([]string, error) {
	var headlines []string
	err := r.DB.Table("ninelives_newsfeed_for_today_1").Find(&headlines).Error
	if err != nil {
		return nil, fmt.Errorf("get newsfeed: %v", err)
	}
	return headlines, nil
}

// Changelog is the resolver for the changelog field.
func (r *queryResolver) Changelog(ctx context.Context) ([]*changelog.Changelog, error) {
	xs := make([]*changelog.Changelog, len(r.ChangelogItems))
	for i, x := range r.ChangelogItems {
		xs[i] = &x
	}
	return xs, nil
}

// UserActivity is the resolver for the userActivity field.
func (r *queryResolver) UserActivity(ctx context.Context, address string, campaignID *string, page *int, pageSize *int) ([]*types.Activity, error) {
	var activities []*types.Activity
	address = strings.ToLower(address)
	pageNum := 0
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 8
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	query := r.DB.Table("ninelives_buys_and_sells_1").Select("*",
		"created_by AS created_at",
		"transaction_hash AS tx_hash",
		"emitter_addr AS pool_address").Where(&types.Activity{Recipient: address}).Order("created_at DESC")
	if campaignID != nil {
		query = query.Where(&types.Activity{CampaignID: *campaignID})
	}
	err := query.Offset(pageNum * pageSizeNum).Limit(pageSizeNum).Scan(&activities).Error
	if err != nil {
		slog.Error("Error getting activities from database",
			"error", err,
		)
		return nil, fmt.Errorf("error getting activities from database: %w", err)
	}
	return activities, nil
}

// UserParticipatedCampaigns is the resolver for the userParticipatedCampaigns field.
func (r *queryResolver) UserParticipatedCampaigns(ctx context.Context, address string, page *int, pageSize *int) ([]*types.Position, error) {
	var positions []*types.Position
	address = strings.ToLower(address)
	pageNum := 0
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	err := r.DB.Raw(`
	select nc.id as campaign_id, nc."content"
	from ninelives_payoff_unused_1 npu
	join ninelives_campaigns_1 nc
	on nc."content" ->>'poolAddress' = npu.pool_address
	where npu.spender  = ?
	and npu.was_spent = false
	order by npu.created_at desc
	offset ? limit ?;
	`, address, pageNum*pageSizeNum, pageSizeNum).Scan(&positions).Error
	if err != nil {
		slog.Error("Error getting positions from database",
			"error", err,
		)
		return nil, fmt.Errorf("error getting positions from database: %w", err)
	}
	return positions, nil
}

// UserTotalVolume is the resolver for the userTotalVolume field.
func (r *queryResolver) UserTotalVolume(ctx context.Context, address string) (int, error) {
	var totalVolume int
	address = strings.ToLower(address)
	err := r.DB.Raw(`
	select coalesce (SUM(from_amount), 0)
	from ninelives_buys_and_sells_1
	where from_symbol = 'fUSDC' and recipient = ?
	`, address).Scan(&totalVolume).Error
	if err != nil {
		slog.Error("Error getting total volume from database",
			"error", err,
			"address", address,
		)
		return 0, fmt.Errorf("error getting total volume from database: %w", err)
	}
	return totalVolume, nil
}

// PositionsHistory is the resolver for the positionsHistory field.
func (r *queryResolver) PositionsHistory(ctx context.Context, address string, outcomeIds []string) ([]types.Activity, error) {
	var activities []types.Activity
	outcomes := make([]string, len(outcomeIds))
	for i := range outcomeIds {
		// remove hex prefix
		outcomes[i] = outcomeIds[i][2:]
	}
	address = strings.ToLower(address)
	err := r.DB.Table("ninelives_buys_and_sells_1").Select("*",
		"created_by AS created_at",
		"transaction_hash AS tx_hash",
		"emitter_addr AS pool_address").Where("recipient = ?", address).Where("outcome_id IN ?", outcomes).Scan(&activities).Error
	if err != nil {
		slog.Error("Error getting activities from database for the outcome ids",
			"error", err,
			"outcomeIds", outcomeIds,
		)
		return activities, fmt.Errorf("error getting activities from database for the outcome ids: %w", err)
	}
	return activities, nil
}

// UserClaims is the resolver for the userClaims field.
func (r *queryResolver) UserClaims(ctx context.Context, address string, campaignID *string, page *int, pageSize *int) ([]*types.Claim, error) {
	var claims []*types.Claim
	address = strings.ToLower(address)
	pageNum := 0
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	sql := `
	WITH aggregated AS (
    SELECT
        identifier,
        emitter_addr,
        recipient,
        SUM(shares_spent) as shares_spent,
        SUM(fusdc_received) as fusdc_received,
        MAX(created_by) as created_by,
        transaction_hash
    FROM ninelives_events_payoff_activated
    WHERE recipient = ?
    GROUP BY emitter_addr, recipient,identifier, transaction_hash
)
SELECT
    nc.id,
    COALESCE(a.shares_spent, 0) + COALESCE(nelp.shares_spent, 0) AS shares_spent,
    a.transaction_hash,
    COALESCE(a.fusdc_received, 0) + COALESCE(nelp.fusdc_received, 0) AS fusdc_received,
    COALESCE(a.fusdc_received, 0) + COALESCE(nelp.fusdc_received, 0) - fs.fusdc_spent AS pnl,
    a.created_by AS created_at,
    nc.content,
    CONCAT('0x', a.identifier) AS winner
FROM aggregated a
LEFT JOIN ninelives_campaigns_1 nc
    ON a.emitter_addr = nc.content->>'poolAddress'
LEFT JOIN (
    SELECT
        emitter_addr,
        recipient,
        SUM(shares_spent) AS shares_spent,
        SUM(fusdc_received) AS fusdc_received,
        MAX(created_by) AS created_by
    FROM ninelives_events_ninetails_loser_payoff
    GROUP BY emitter_addr, recipient
) nelp
ON a.recipient = nelp.recipient
AND a.emitter_addr = nelp.emitter_addr
LEFT JOIN (
    SELECT
        emitter_addr,
         SUM(
            CASE
                WHEN nbas.type = 'buy'  THEN nbas.from_amount
                WHEN nbas.type = 'sell' THEN -nbas.to_amount
            END
        ) AS fusdc_spent
    FROM ninelives_buys_and_sells_1 nbas
    WHERE recipient = ?
    GROUP BY emitter_addr
) fs
    ON fs.emitter_addr = a.emitter_addr
	`
	args := []interface{}{address, address}
	if campaignID != nil {
		sql += " WHERE nc.id = ?"
		args = append(args, *campaignID)
	}
	sql += ` ORDER BY COALESCE(
    GREATEST(a.created_by, nelp.created_by),
    a.created_by,
    nelp.created_by
	) DESC
	OFFSET ?
	LIMIT ?;`
	args = append(args, pageNum*pageSizeNum, pageSizeNum)
	err := r.DB.Raw(sql, args...).Scan(&claims).Error
	if err != nil {
		slog.Error("Error getting reward claims from database",
			"error", err,
			"outcomeIds", campaignID,
		)
		return nil, fmt.Errorf("error getting reward claims from database: %w", err)
	}
	return claims, nil
}

// UserProfile is the resolver for the userProfile field.
func (r *queryResolver) UserProfile(ctx context.Context, address string) (*types.Profile, error) {
	address = strings.ToLower(address)

	var profile types.Profile
	err := r.DB.Table("ninelives_users_1").Where("wallet_address = ?", address).Scan(&profile).Error
	if err != nil {
		slog.Error("Error getting profile from database",
			"error", err,
			"wallet address", address,
		)
		return nil, fmt.Errorf("error getting profile from database: %w", err)
	}
	return &profile, nil
}

// UserLiquidity is the resolver for the userLiquidity field.
func (r *queryResolver) UserLiquidity(ctx context.Context, address string, tradingAddr *string) (string, error) {
	address = strings.ToLower(address)

	var emitterCondition string
	var args []interface{}
	args = append(args, address)

	if tradingAddr != nil {
		lowered := strings.ToLower(*tradingAddr)
		emitterCondition = "AND emitter_addr = ?"
		args = append(args, lowered, address, lowered)
	} else {
		emitterCondition = ""
		args = append(args, address)
	}

	query := fmt.Sprintf(`
		SELECT
			COALESCE((
				SELECT SUM(liquidity_shares)
				FROM ninelives_events_liquidity_added
				WHERE recipient = ? %s
			), 0)
			-
			COALESCE((
				SELECT SUM(fusdc_amt)
				FROM ninelives_events_liquidity_removed
				WHERE recipient = ? %s
			), 0)
		AS total_shares;
	`, emitterCondition, emitterCondition)

	var liquidity string
	err := r.DB.Raw(query, args...).Scan(&liquidity).Error
	if err != nil {
		slog.Error("Error getting liquidity from database",
			"error", err,
			"wallet address", address,
		)
		return "", fmt.Errorf("error getting liquidity from database: %w", err)
	}
	return liquidity, nil
}

// ReferrersForAddress is the resolver for the referrersForAddress field.
func (r *queryResolver) ReferrersForAddress(ctx context.Context, address string) ([]string, error) {
	if address == "" {
		return nil, nil
	}
	address = strings.ToLower(address)
	var codes []struct {
		Code string
	}
	err := r.DB.Table("ninelives_referrer_1").
		Where("owner = ?", address).
		Select("code").
		Limit(10).
		Scan(&codes).
		Error
	if err != nil {
		slog.Error("Error getting codes for referrer",
			"error", err,
			"address", address,
		)
		return nil, fmt.Errorf("error getting codes for referrer")
	}
	xs := make([]string, len(codes))
	for i := 0; i < len(xs); i++ {
		xs[i] = codes[i].Code
	}
	return xs, nil
}

// Leaderboards is the resolver for the leaderboards field.
func (r *queryResolver) Leaderboards(ctx context.Context) (*model.LeaderboardWeekly, error) {
	var (
		referrerLeaderboard []model.LeaderboardPosition
		volumeLeaderboard   []model.LeaderboardPosition
		creatorLeaderboard  []model.LeaderboardPosition
	)
	oneWeekAgo := time.Now().AddDate(0, 0, -7)
	err := r.DB.Table("ninelives_events_referrer_earned_fees").
		Select("recipient as address, SUM(volume) as volume").
		Where("created_by >= ?", oneWeekAgo).
		Group("recipient").
		Order("volume DESC").
		Limit(25).
		Scan(&referrerLeaderboard).
		Error
	if err != nil {
		slog.Error("Failed to get referrer leaderboard",
			"error", err,
		)
		return nil, fmt.Errorf("failed to get leaderboard")
	}
	err = r.DB.Table("ninelives_buys_and_sells_1").
		Select("recipient as address, SUM(from_amount) as volume").
		Where("created_by >= ? AND from_symbol = 'fUSDC'", oneWeekAgo).
		Group("address").
		Order("volume DESC").
		Limit(25).
		Scan(&volumeLeaderboard).
		Error
	if err != nil {
		slog.Error("Failed to get volume leaderboard",
			"error", err,
		)
		return nil, fmt.Errorf("failed to get leaderboard")
	}
	err = r.DB.Table("ninelives_campaigns_1").
		Select("content->'creator'->>'address' as address, SUM(total_volume) as volume").
		Where("created_at >= ? AND content->'creator'->>'address' IS NOT NULL", oneWeekAgo).
		Group("content->'creator'->>'address'").
		Order("SUM(total_volume) DESC").
		Limit(10).
		Scan(&creatorLeaderboard).
		Error
	if err != nil {
		slog.Error("Failed to get creator leaderboard",
			"error", err,
		)
		return nil, fmt.Errorf("failed to get leaderboard")
	}
	l := model.LeaderboardWeekly{
		Referrers: referrerLeaderboard,
		Volume:    volumeLeaderboard,
		Creators:  creatorLeaderboard,
	}
	return &l, nil
}

// ReferrerByCode is the resolver for the referrerByCode field.
func (r *queryResolver) ReferrerByCode(ctx context.Context, code string) (string, error) {
	var owner string
	err := r.DB.Table("ninelives_referrer_1").
		Where("code = ?", code).
		Select("owner").Scan(&owner).Error
	if err != nil {
		slog.Error("Error getting referrer by code",
			"error", err,
			"code", code,
		)
		return "", fmt.Errorf("error getting referrer by code")
	}
	return owner, nil
}

// FeaturedCampaign is the resolver for the featuredCampaign field.
func (r *queryResolver) FeaturedCampaign(ctx context.Context, limit *int) ([]types.Campaign, error) {
	var campaigns []types.Campaign
	const defaultLimit = 12

	n := defaultLimit
	if limit != nil {
		n = *limit
	}
	err := r.DB.Raw(`
	SELECT *
	FROM private_ninelives_campaigns_sorted_by_breakout_4
	WHERE content->>'winner' IS NULL
	LIMIT ?
	`, n).Scan(&campaigns).Error
	if err != nil {
		slog.Error("Error getting featured campaigns",
			"error", err,
			"limit", n,
		)
		return nil, fmt.Errorf("error getting featured campaigns: %w", err)
	}
	return campaigns, nil
}

// UserLPs is the resolver for the userLPs field.
func (r *queryResolver) UserLPs(ctx context.Context, address string) ([]types.LP, error) {
	var lps []types.LP
	address = strings.ToLower(address)
	err := r.DB.Raw(`
	SELECT
    COALESCE(added.total_added, 0) - COALESCE(removed.total_removed, 0) AS liquidity,
    nc.*
	FROM
		(
			SELECT emitter_addr, SUM(fusdc_amt) AS total_added
			FROM ninelives_events_liquidity_added
			WHERE recipient = ?
			GROUP BY emitter_addr
		) AS added
	LEFT JOIN
		(
			SELECT emitter_addr, SUM(fusdc_amt) AS total_removed
			FROM ninelives_events_liquidity_removed
			WHERE recipient = ?
			GROUP BY emitter_addr
		) AS removed
    ON added.emitter_addr = removed.emitter_addr
	JOIN
    ninelives_campaigns_1 AS nc
    ON nc.content->>'poolAddress' = added.emitter_addr
	WHERE COALESCE(added.total_added, 0) - COALESCE(removed.total_removed, 0) > 0
	ORDER BY nc.content->>'starting' DESC
	`, address, address).Scan(&lps).Error
	if err != nil {
		slog.Error("Error getting user lps",
			"error", err,
		)
		return nil, fmt.Errorf("error getting user lps: %w", err)
	}
	return lps, nil
}

// CountReferees is the resolver for the countReferees field.
func (r *queryResolver) CountReferees(ctx context.Context, referrerAddress string) (int, error) {
	var count int
	referrerAddress = strings.ToLower(referrerAddress)
	err := r.DB.Raw(`
	select count(*)
	from ninelives_users_1 u
	where u.settings->>'referrer' = ?
	and u.wallet_address != ?
	`, referrerAddress, referrerAddress).Scan(&count).Error
	if err != nil {
		return 0, fmt.Errorf("Query failed from db")
	}
	return count, nil
}

// CampaignComments is the resolver for the campaignComments field.
func (r *queryResolver) CampaignComments(ctx context.Context, campaignID string, onlyHolders *bool, page *int, pageSize *int) ([]*types.Comment, error) {
	var comments []*types.Comment
	pageNum := 0
	if page != nil {
		pageNum = *page
	}
	pageSizeNum := 10
	if pageSize != nil {
		pageSizeNum = *pageSize
	}
	whereExtra := ""
	if onlyHolders != nil && *onlyHolders {
		whereExtra = " AND json_array_length(COALESCE(investments.investments, '[]')) > 0"
	}
	query := `
	SELECT
    nc.*,
    COALESCE(investments.investments, '[]') AS investments
	FROM ninelives_comments_1 AS nc
	LEFT JOIN LATERAL (
    SELECT JSON_AGG(
               JSON_BUILD_OBJECT(
                   'id', CONCAT('0x', t.outcome_id),
                   'amount', t.investment
               )
           ) AS investments
    FROM (
        SELECT
            nbas.outcome_id,
            SUM(
                CASE
                    WHEN nbas.type = 'buy' THEN nbas.from_amount
                    ELSE -nbas.from_amount
                END
            ) AS investment
        FROM ninelives_buys_and_sells_1 AS nbas
        WHERE nbas.campaign_id = nc.campaign_id
          AND nbas.recipient = nc.wallet_address
        GROUP BY nbas.outcome_id
    ) t
	) investments ON true
	WHERE nc.campaign_id = ?` + whereExtra + `
	ORDER BY nc.created_at DESC
	OFFSET ? LIMIT ?
	`
	err := r.DB.Raw(query, campaignID, pageNum*pageSizeNum, pageSizeNum).Scan(&comments).Error
	if err != nil {
		slog.Error("Error getting campaign's comments",
			"error", err,
		)
		return nil, fmt.Errorf("Error getting campaign's comments %w", err)
	}
	return comments, nil
}

// CampaignPriceEvents is the resolver for the campaignPriceEvents field.
func (r *queryResolver) CampaignPriceEvents(ctx context.Context, poolAddress string) ([]*types.PriceEvent, error) {
	var events []*types.PriceEvent
	err := r.DB.Raw(`
	SELECT created_by as created_at, shares
	FROM ninelives_events_amm_details
	WHERE emitter_addr = ?
	`, poolAddress).Scan(&events).Error
	if err != nil {
		return nil, fmt.Errorf("Error getting price change events")
	}
	return events, nil
}

// CampaignWeeklyVolume is the resolver for the campaignWeeklyVolume field.
func (r *queryResolver) CampaignWeeklyVolume(ctx context.Context, poolAddress string) (int, error) {
	var volume int
	poolAddress = strings.ToLower(poolAddress)
	err := r.DB.Raw(`
	select
	COALESCE(sum(case when type = 'buy' THEN from_amount else to_amount end), 0) as volume
	from ninelives_buys_and_sells_1
	where emitter_addr = ? and created_by >= NOW() - INTERVAL '7 days';
	`, poolAddress).Scan(&volume).Error
	if err != nil {
		return 0, fmt.Errorf("Error getting weekly volume")
	}
	return volume, nil
}

// CampaignBySymbol is the resolver for the campaignBySymbol field.
func (r *queryResolver) CampaignBySymbol(ctx context.Context, symbol string, category string) (*types.Campaign, error) {
	var campaign types.Campaign
	categoryJSON, _ := json.Marshal(category)
	err := r.DB.Raw(`
	SELECT nc.*, nmods.odds
	FROM ninelives_campaigns_1 AS nc
	LEFT JOIN (
		SELECT DISTINCT ON (pool_address) * FROM ninelives_market_odds_snapshot_1 ORDER BY pool_address, created_by DESC
	) AS nmods on nmods.pool_address = nc.content->>'poolAddress'
	WHERE content->'priceMetadata'->>'baseAsset' = ?
	AND content->'categories' @> ?
	AND EXTRACT(EPOCH FROM NOW()) BETWEEN (content->>'starting')::numeric AND (content->>'ending')::numeric
	LIMIT 1
	`, symbol, string(categoryJSON)).Scan(&campaign).Error
	if err != nil {
		return nil, fmt.Errorf("Error getting the live campaign by symbol")
	}
	if campaign.ID == "" {
		err = r.DB.Raw(`
			SELECT nc.*, nmods.odds
			FROM ninelives_campaigns_1 as nc
			LEFT JOIN (
			SELECT DISTINCT ON (pool_address) * FROM ninelives_market_odds_snapshot_1 ORDER BY pool_address, created_by DESC
			) AS nmods on nmods.pool_address = nc.content->>'poolAddress'
			WHERE content->'priceMetadata'->>'baseAsset' = ?
			AND content->'categories' @> ?
			AND (content->>'starting')::numeric <= EXTRACT(EPOCH FROM NOW())
			ORDER BY created_at DESC
			LIMIT 1
		`, symbol, string(categoryJSON)).Scan(&campaign).Error

		if err != nil {
			return nil, fmt.Errorf("error getting latest campaign by symbol: %w", err)
		}
	}

	return &campaign, nil
}

// TimebasedCampaigns is the resolver for the timebasedCampaigns field.
func (r *queryResolver) TimebasedCampaigns(ctx context.Context, categories []string, tokens []string) ([]*types.Campaign, error) {
	var campaigns []*types.Campaign
	jsonCategories, err := json.Marshal(categories)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal categories: %w", err)
	}
	query := `
	SELECT DISTINCT ON (nc.content->'priceMetadata'->>'baseAsset')
		nc.id,
		nc.content,
		nc.created_at,
		nc.updated_at,
		nmods.odds
	FROM ninelives_campaigns_1 as nc
	LEFT JOIN (
		SELECT DISTINCT ON (pool_address) * FROM ninelives_market_odds_snapshot_1 ORDER BY pool_address, created_by DESC
	) AS nmods on nmods.pool_address = nc.content->>'poolAddress'
	WHERE nc.content->'categories' @> ?::jsonb
	AND (nc.content->>'starting')::numeric <= EXTRACT(EPOCH FROM NOW())
	`
	args := []interface{}{string(jsonCategories)}
	if len(tokens) > 0 {
		query += "AND nc.content->'priceMetadata'->>'baseAsset' = ANY(?) "
		args = append(args, pq.Array(tokens))
	}
	query += `
	ORDER BY nc.content->'priceMetadata'->>'baseAsset', nc.created_at DESC;
	`
	err = r.DB.Raw(query, args...).Scan(&campaigns).Error
	if err != nil {
		return nil, fmt.Errorf("error getting timebased campaigns: %w", err)
	}
	return campaigns, nil
}

// UnclaimedCampaigns is the resolver for the unclaimedCampaigns field.
func (r *queryResolver) UnclaimedCampaigns(ctx context.Context, address string, token *string) ([]*types.UnclaimedCampaign, error) {
	address = strings.ToLower(address)
	var campaigns []*types.UnclaimedCampaign
	args := []any{address, address}
	query := `
	select
	bs_sum.campaign_id as id,
	py.created_at,
	bs_sum.campaign_content as content,
    bs_sum.total_spent
	from ninelives_payoff_unused_1 py
	join (
    select
        emitter_addr,
        campaign_id,
        sum(from_amount) as total_spent,
        campaign_content
    from ninelives_buys_and_sells_1
    where recipient = ?
    group by emitter_addr,campaign_id, campaign_content
	) bs_sum
    on py.pool_address  = bs_sum.emitter_addr
	where
    py.spender = ?
    and py.was_spent = false
	and bs_sum.campaign_content->>'winner' is not null
	`
	if token != nil {
		query += ` and bs_sum.campaign_content->'priceMetadata'->>'baseAsset' = ?`
		args = append(args, strings.ToUpper(*token))
	} else {
		query += ` and bs_sum.campaign_content->'priceMetadata' is not null`
	}
	query += ` order by py.created_at desc`
	err := r.DB.Raw(query, args...).Scan(&campaigns).Error
	if err != nil {
		return nil, fmt.Errorf("error getting unclaimed campaigns: %w", err)
	}
	return campaigns, nil
}

// Assets is the resolver for the assets field.
func (r *queryResolver) Assets(ctx context.Context) ([]types.Asset, error) {
	var assets []types.Asset
	err := r.DB.Raw(`
	select sum(nbas.from_amount) as total_spent,
	nbas.campaign_content->'priceMetadata'->>'baseAsset' as name
	from ninelives_buys_and_sells_1 nbas
	where nbas.campaign_content->'priceMetadata'->>'baseAsset' is not null
	and nbas.created_by >= NOW() - INTERVAL '24 hours'
	group by nbas.campaign_content->'priceMetadata'->>'baseAsset'
	order by total_spent desc
	`).Scan(&assets).Error
	if err != nil {
		return nil, fmt.Errorf("error getting assets: %w", err)
	}
	return assets, nil
}

// TotalPnL is the resolver for the totalPnL field.
func (r *queryResolver) TotalPnL(ctx context.Context, address string, fromTs *int, untilTs *int) (*types.Pnl, error) {
	var pnl types.Pnl
	address = strings.ToLower(address)
	var (
		from  = time.Unix(1, 1)
		until = time.Now()
	)
	if fromTs != nil {
		from = time.Unix(int64(*fromTs), 0)
	}
	if untilTs != nil {
		until = time.Unix(int64(*untilTs), 0)
	}
	q := `
WITH payoff AS (
	SELECT
		emitter_addr,
		SUM(fusdc_received) AS fusdc_received
	FROM ninelives_events_payoff_activated
	WHERE recipient = $3
	  AND created_by >= $1
	  AND created_by < $2
	GROUP BY emitter_addr
),
loser_payoff AS (
	SELECT
		emitter_addr,
		SUM(fusdc_received) AS fusdc_received
	FROM ninelives_events_ninetails_loser_payoff
	WHERE recipient = $3
	  AND created_by >= $1
	  AND created_by < $2
	GROUP BY emitter_addr
),
spent AS (
	SELECT
		emitter_addr,
		 SUM(
			CASE
				WHEN type = 'buy'  THEN from_amount
				WHEN type = 'sell' THEN -to_amount
			END
		) AS fusdc_spent
	FROM ninelives_buys_and_sells_1
	WHERE recipient = $3
	  AND created_by >= $1
	  AND created_by < $2
	GROUP BY emitter_addr
),
all_emitters AS (
	SELECT emitter_addr FROM payoff
	UNION
	SELECT emitter_addr FROM loser_payoff
	UNION
	SELECT emitter_addr FROM spent
)
SELECT
	SUM(
		COALESCE(p.fusdc_received, 0)
	  + COALESCE(l.fusdc_received, 0)
	  - COALESCE(s.fusdc_spent, 0)
	) AS total_pnl,
	COALESCE(SUM(s.fusdc_spent), 0) AS volume
FROM all_emitters e
LEFT JOIN payoff p ON p.emitter_addr = e.emitter_addr
LEFT JOIN loser_payoff l ON l.emitter_addr = e.emitter_addr
LEFT JOIN spent s ON s.emitter_addr = e.emitter_addr`
	err := r.DB.Raw(q, from, until, address).Scan(&pnl).Error
	if err != nil {
		return nil, fmt.Errorf("error getting pnl: %w", err)
	}
	return &pnl, nil
}

// GetFinalPrice is the resolver for the getFinalPrice field.
func (r *queryResolver) GetFinalPrice(ctx context.Context, symbol string, ending int) (string, error) {
	var finalPrice string
	symbol = strings.ToUpper(symbol)
	var endingTime time.Time
	if int64(ending) > 1e11 {
		seconds := int64(ending) / 1000
		nanoseconds := (int64(ending) % 1000) * 1e6
		endingTime = time.Unix(seconds, nanoseconds)
	} else {
		endingTime = time.Unix(int64(ending), 0)
	}
	err := r.DB.Raw(`
	select amount
	from oracles_ninelives_prices_2
	where base = ?
	and created_by >= ?
	order by created_by desc
	limit 1
	`, symbol, endingTime).Scan(&finalPrice).Error
	if err != nil {
		return "NaN", err
	}
	return finalPrice, nil
}

// Refererr is the resolver for the refererr field.
func (r *settingsResolver) Refererr(ctx context.Context, obj *types.Settings) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("Settings is nil")
	}
	return &obj.Referrer, nil
}

// Activity returns ActivityResolver implementation.
func (r *Resolver) Activity() ActivityResolver { return &activityResolver{r} }

// Campaign returns CampaignResolver implementation.
func (r *Resolver) Campaign() CampaignResolver { return &campaignResolver{r} }

// Changelog returns ChangelogResolver implementation.
func (r *Resolver) Changelog() ChangelogResolver { return &changelogResolver{r} }

// Claim returns ClaimResolver implementation.
func (r *Resolver) Claim() ClaimResolver { return &claimResolver{r} }

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Position returns PositionResolver implementation.
func (r *Resolver) Position() PositionResolver { return &positionResolver{r} }

// PriceEvent returns PriceEventResolver implementation.
func (r *Resolver) PriceEvent() PriceEventResolver { return &priceEventResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Settings returns SettingsResolver implementation.
func (r *Resolver) Settings() SettingsResolver { return &settingsResolver{r} }

type activityResolver struct{ *Resolver }
type campaignResolver struct{ *Resolver }
type changelogResolver struct{ *Resolver }
type claimResolver struct{ *Resolver }
type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type positionResolver struct{ *Resolver }
type priceEventResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type settingsResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *campaignResolver) Odds(ctx context.Context, obj *types.Campaign) (types.Odds, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Odds, nil
}
