package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"encoding/hex"
	"fmt"
	"log/slog"
	"net/url"
	"strings"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/fluidity-money/9lives.so/cmd/graphql.ethereum/graph/model"
	"github.com/fluidity-money/9lives.so/lib/crypto"
	"github.com/fluidity-money/9lives.so/lib/features"
	"github.com/fluidity-money/9lives.so/lib/types"
	"github.com/fluidity-money/9lives.so/lib/types/changelog"
)

// Name is the resolver for the name field.
func (r *campaignResolver) Name(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.Name, nil
}

// Description is the resolver for the description field.
func (r *campaignResolver) Description(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.Description, nil
}

// Picture is the resolver for the picture field.
func (r *campaignResolver) Picture(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.Picture, nil
}

// Creator is the resolver for the creator field.
func (r *campaignResolver) Creator(ctx context.Context, obj *types.Campaign) (*types.Wallet, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Creator, nil
}

// Settlement is the resolver for the settlement field.
func (r *campaignResolver) Settlement(ctx context.Context, obj *types.Campaign) (model.SettlementType, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return model.SettlementType(obj.Content.Settlement), nil
}

// OracleDescription is the resolver for the oracleDescription field.
func (r *campaignResolver) OracleDescription(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.OracleDescription, nil
}

// OracleUrls is the resolver for the oracleUrls field.
func (r *campaignResolver) OracleUrls(ctx context.Context, obj *types.Campaign) ([]*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.OracleUrls, nil
}

// Identifier is the resolver for the identifier field.
func (r *campaignResolver) Identifier(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.ID, nil
}

// PoolAddress is the resolver for the poolAddress field.
func (r *campaignResolver) PoolAddress(ctx context.Context, obj *types.Campaign) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("campaign is nil")
	}
	return obj.Content.PoolAddress, nil
}

// Outcomes is the resolver for the outcomes field.
func (r *campaignResolver) Outcomes(ctx context.Context, obj *types.Campaign) ([]types.Outcome, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Outcomes, nil
}

// Starting is the resolver for the starting field.
func (r *campaignResolver) Starting(ctx context.Context, obj *types.Campaign) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Starting, nil
}

// Ending is the resolver for the ending field.
func (r *campaignResolver) Ending(ctx context.Context, obj *types.Campaign) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Ending, nil
}

// X is the resolver for the x field.
func (r *campaignResolver) X(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.X, nil
}

// Telegram is the resolver for the telegram field.
func (r *campaignResolver) Telegram(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Telegram, nil
}

// Web is the resolver for the web field.
func (r *campaignResolver) Web(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Web, nil
}

// Winner is the resolver for the winner field.
func (r *campaignResolver) Winner(ctx context.Context, obj *types.Campaign) (*string, error) {
	if obj == nil {
		return nil, fmt.Errorf("campaign is nil")
	}
	return obj.Content.Winner, nil
}

// ID is the resolver for the id field.
func (r *changelogResolver) ID(ctx context.Context, obj *changelog.Changelog) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty changelog")
	}
	return fmt.Sprintf("%v-%v", obj.Time, obj.Title), nil
}

// AfterTs is the resolver for the afterTs field.
func (r *changelogResolver) AfterTs(ctx context.Context, obj *changelog.Changelog) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("empty changelog")
	}
	return int(obj.Time.Unix()), nil
}

// HTML is the resolver for the html field.
func (r *changelogResolver) HTML(ctx context.Context, obj *changelog.Changelog) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty changelog")
	}
	return obj.HtmlContent, nil
}

// ExplainCampaign is the resolver for the explainCampaign field.
func (r *mutationResolver) ExplainCampaign(ctx context.Context, typeArg model.Modification, name string, description string, picture string, seed int, outcomes []model.OutcomeInput, ending int, starting int, creator string, oracleDescription *string, oracleUrls []*string, x *string, telegram *string, web *string) (*bool, error) {
	outcomes_ := make([]crypto.Outcome, len(outcomes))
	if seed < 0 {
		return nil, fmt.Errorf("negative seed")
	}
	for i, o := range outcomes {
		outcomes_[i] = crypto.Outcome{
			Name: o.Name,
			Desc: o.Description,
			Seed: uint64(o.Seed),
		}
	}
	marketId := crypto.GetMarketId(outcomes_)
	tradingAddr, err := getTradingAddr(r.Geth, r.FactoryAddr, marketId)
	if err != nil {
		slog.Error("Error checking if trading contract is deployed",
			"trading contract", tradingAddr,
			"factory address", r.FactoryAddr,
			"market id", marketId,
			"error", err,
		)
		return nil, fmt.Errorf("error checking if trading contract is deployed")
	}
	settlement, err := getSettlementTypeDesc(
		r.Geth,
		r.InfraMarketAddr,
		r.BeautyContestAddr,
		r.SarpAiAddr,
		*tradingAddr,
	)
	if err != nil {
		slog.Error("Failed to get the settlement type description",
			"trading contract", tradingAddr,
			"factory address", r.FactoryAddr,
			"market id", marketId,
			"error", err,
		)
		return nil, fmt.Errorf("error retrieving oracle type")
	}
	// Create the campaign object
	campaignId, _ := crypto.GetOutcomeId(name, description, uint64(seed))
	hexCampaignId := "0x" + hex.EncodeToString(campaignId)
	contractOwner_, err := getOwner(r.Geth, r.FactoryAddr, *tradingAddr)
	if err != nil {
		slog.Error("Error checking if trading contract is deployed",
			"trading contract", tradingAddr,
			"factory address", r.FactoryAddr,
			"market id", marketId,
			"error", err,
		)
		return nil, fmt.Errorf("error checking if trading contract is deployed")
	}
	creator = strings.ToLower(creator)
	var (
		tradingAddrStr = strings.ToLower(tradingAddr.Hex())
		contractOwner  = strings.ToLower(contractOwner_.Hex())
	)
	// Quick check to see if the entry already exists in the database.
	var campaignIdCount int64
	err = r.DB.Table("ninelives_campaigns_1").
		Where("id = ?", hexCampaignId).
		Count(&campaignIdCount).
		Error
	if err != nil {
		slog.Error("Error checking the existence of this trading addr",
			"trading contract", tradingAddr,
			"factory address", r.FactoryAddr,
			"market id", marketId,
			"error", err,
		)
		return nil, fmt.Errorf("error finding trading addr existence")
	}
	if campaignIdCount > 0 {
		return nil, fmt.Errorf("trading addr already exists")
	}
	if contractOwner != creator {
		slog.Error("Staged creator is not the contract owner",
			"trading contract", tradingAddr,
			"contractOwner", contractOwner,
			"factory address", r.FactoryAddr,
			"market id", marketId,
			"submitted creator", creator,
		)
		return nil, fmt.Errorf(
			"staged creator is not the contract owner for id %x, owner is %v",
			marketId,
			contractOwner,
		)
	}
	// Create outcomes object
	var campaignOutcomes = make([]types.Outcome, len(outcomes))
	for i, outcome := range outcomes {
		outcomeId, _ := crypto.GetOutcomeId(
			outcome.Name,
			outcome.Description,
			uint64(outcome.Seed),
		)
		hexOutcomeId := "0x" + hex.EncodeToString(outcomeId)
		shareAddr, _ := getShareAddr(r.Geth, *tradingAddr, [8]byte(outcomeId))
		shareAddrStr := strings.ToLower(shareAddr.Hex())
		var outcomePicUrl string
		if pic := outcome.Picture; pic != "" {
			buf, err := decodeAndCheckPictureValidity(outcome.Picture)
			if err != nil {
				slog.Error("Failed to decode outcome image",
					"err", err,
					"share addr", shareAddr,
					"outcome id", outcomeId,
					"trading addr", tradingAddr,
				)
				return nil, fmt.Errorf("bad outcome image")
			}
			picKey := fmt.Sprintf("%v-%v", tradingAddr, shareAddr)
			_, err = r.S3UploadManager.Upload(ctx, &s3.PutObjectInput{
				Bucket: aws.String(r.S3UploadBucketName),
				Key:    aws.String(picKey),
				Body:   buf,
			})
			if err != nil {
				slog.Error("Failed to upload a outcome image",
					"trading addr", tradingAddr,
					"outcome key", picKey,
					"creator", creator,
					"err", err,
				)
				return nil, fmt.Errorf("error uploading image")
			}
			// Track the URL that's associated with this share's picture.
			outcomePicUrl, err = url.JoinPath(r.PicturesUriBase, picKey)
			if err != nil {
				slog.Error("Failed to create a URL for a share picture",
					"picture", picture,
					"trading addr", tradingAddr,
					"outcome key", picKey,
					"creator", creator,
					"err", err,
				)
				return nil, fmt.Errorf("error uploading image")
			}
		}
		campaignOutcomes[i] = types.Outcome{
			Name:        outcome.Name,
			Description: outcome.Description,
			Picture:     outcomePicUrl,
			Seed:        outcome.Seed,
			Identifier:  hexOutcomeId,
			Share: &types.Share{
				Address: shareAddrStr,
			},
		}
	}
	// Upload the image for the base to S3, so we can serve it later,
	// start by unpacking the base64. This should also blow up if this
	// is bad base64.
	buf, err := decodeAndCheckPictureValidity(picture)
	if err != nil {
		slog.Error("Failed to decode a image",
			"trading addr", tradingAddr,
			"creator", creator,
			"err", err,
		)
		return nil, fmt.Errorf("error uploading image")
	}
	tradingPicKey := tradingAddrStr + "-base"
	_, err = r.S3UploadManager.Upload(ctx, &s3.PutObjectInput{
		Bucket: aws.String(r.S3UploadBucketName),
		Key:    aws.String(tradingPicKey),
		Body:   buf,
	})
	if err != nil {
		slog.Error("Failed to upload a trading image",
			"picture", picture,
			"trading addr", tradingAddr,
			"trading pic key", tradingPicKey,
			"err", err,
		)
		return nil, fmt.Errorf("error uploading image")
	}
	tradingPicUrl, err := url.JoinPath(r.PicturesUriBase, tradingPicKey)
	if err != nil {
		slog.Error("Failed to join a trading image path",
			"trading addr", tradingAddr,
			"trading pic key", tradingPicKey,
			"err", err,
		)
		return nil, fmt.Errorf("error uploading image")
	}
	campaign := types.Campaign{
		ID: hexCampaignId,
		Content: types.CampaignContent{
			Name:        name,
			Description: description,
			Picture:     tradingPicUrl,
			Seed:        seed,
			Creator: &types.Wallet{
				Address: creator,
			},
			Settlement:        string(settlement),
			OracleDescription: oracleDescription,
			OracleUrls:        oracleUrls,
			PoolAddress:       tradingAddrStr,
			Outcomes:          campaignOutcomes,
			Ending:            ending,
			Starting:          starting,
			X:                 x,
			Telegram:          telegram,
			Web:               web,
		},
	}
	result := r.DB.Table("ninelives_campaigns_1").Create(&campaign)
	if result.Error != nil {
		slog.Error("Error inserting campaign into database",
			"error", result.Error,
		)
		return nil, fmt.Errorf("error inserting campaign into database")
	}
	res := true
	return &res, nil
}

// RevealCommitment is the resolver for the revealCommitment field.
func (r *mutationResolver) RevealCommitment(ctx context.Context, tradingAddr *string, sender *string, seed *string, preferredOutcome *string) (*bool, error) {
	panic(fmt.Errorf("not implemented: RevealCommitment - revealCommitment"))
}

// RevealCommitment2 is the resolver for the revealCommitment2 field.
func (r *mutationResolver) RevealCommitment2(ctx context.Context, tradingAddr *string, sender *string, seed *string, preferredOutcome *string, rr *string, s *string, v *string) (*bool, error) {
	panic(fmt.Errorf("not implemented: RevealCommitment2 - revealCommitment2"))
}

// Campaigns is the resolver for the campaigns field.
func (r *queryResolver) Campaigns(ctx context.Context, category []string) ([]types.Campaign, error) {
	var campaigns []types.Campaign
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		campaigns = MockGraphCampaigns()
		return campaigns, nil
	}
	err := r.DB.Raw(
		`SELECT 
    nc.*, 
    COALESCE(nbas.total_volume, 0) AS total_volume
FROM 
    ninelives_campaigns_1 nc
LEFT JOIN (
    SELECT 
        campaign_id, 
        MAX(total_volume) AS total_volume
    FROM 
        ninelives_buys_and_sells_1
    GROUP BY 
        campaign_id
) nbas
ON 
    nc.id = nbas.campaign_id
ORDER BY 
    total_volume DESC;`,
	).
		Scan(&campaigns).
		Error
	if err != nil {
		slog.Error("Error getting campaigns from database",
			"error", err,
		)
		return nil, fmt.Errorf("error getting campaigns from database")
	}
	return campaigns, nil
}

// CampaignByID is the resolver for the campaignById field.
func (r *queryResolver) CampaignByID(ctx context.Context, id string) (*types.Campaign, error) {
	if id == "" || !strings.HasPrefix(id, "0x") {
		return nil, fmt.Errorf("bad id")
	}
	var c types.Campaign
	err := r.DB.Raw(
		`SELECT 
			nc.*, 
			COALESCE(nbas.total_volume, 0) AS total_volume
		FROM 
			ninelives_campaigns_1 nc
		LEFT JOIN (
			SELECT 
				campaign_id, 
				MAX(total_volume) AS total_volume
			FROM 
				ninelives_buys_and_sells_1
			WHERE 
				campaign_id = ?
			GROUP BY 
				campaign_id
		) nbas
		ON 
			nc.id = nbas.campaign_id
		WHERE 
			nc.id = ?`, id, id).
		Scan(&c).
		Error
	if err != nil {
		return nil, fmt.Errorf("campaign find: %v", err)
	}
	return &c, nil
}

// SuggestedHeadlines is the resolver for the suggestedHeadlines field.
func (r *queryResolver) SuggestedHeadlines(ctx context.Context) ([]string, error) {
	var headlines []string
	err := r.DB.Table("ninelives_newsfeed_for_today_1").Find(&headlines).Error
	if err != nil {
		return nil, fmt.Errorf("get newsfeed: %v", err)
	}
	return headlines, nil
}

// Changelog is the resolver for the changelog field.
func (r *queryResolver) Changelog(ctx context.Context) ([]*changelog.Changelog, error) {
	xs := make([]*changelog.Changelog, len(r.ChangelogItems))
	for i, x := range r.ChangelogItems {
		xs[i] = &x
	}
	return xs, nil
}

// Campaign returns CampaignResolver implementation.
func (r *Resolver) Campaign() CampaignResolver { return &campaignResolver{r} }

// Changelog returns ChangelogResolver implementation.
func (r *Resolver) Changelog() ChangelogResolver { return &changelogResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type campaignResolver struct{ *Resolver }
type changelogResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
