
type Query {
  """
  Campaign List that can be filtered according to categories
  """
  campaigns(category: [String!], orderBy: String, searchTerm: String, page: Int, pageSize: Int): [Campaign!]!

  """
  Get a campaign by its ID. May or may not exist.
  """
  campaignById(id: String!): Campaign

  """
  Suggested headlines for the day based on AI input.
  """
  suggestedHeadlines: [String!]!

  """
  Any new changelog items that have come up recently.
  """
  changelog: [Changelog]!

  """
  Returns user's created campaigns
  """
  userCampaigns(address: String!): [Campaign]!

  """
  Returns user's buy and sell activities
  """
  userActivity(address: String!, campaignId: String, page: Int, pageSize: Int): [Activity]!

  """
  Returns user's participated positions as pool address of the campaigns
  and bought and sought outcome ids
  """
  userParticipatedCampaigns(address: String!): [Position]!

  """
  Returns total volume of user's all buy and sell actions
  """
  userTotalVolume(address: String!): Int!
}

"""
Participated pool address of the campaign and bought and sought outcome ids
"""
type Position {
  campaignId: String!

  outcomeIds: [String!]!

  content: Campaign
}

"""
Outcome associated with a Campaign creation that's notified to the graph.
"""
input OutcomeInput {
  """
  Name of the campaign outcome. Ie, "Donald Trump" for the election.
  """
  name: String!

  """
  Randomly chosen seed for the creation of the identifier.
  """
  seed: Int!

  """
  Picture of the outcome.
  """
  picture: String
}

type Mutation {
  """
  "Explain" a campaign, so an on-chain campaign creation is listed in the frontend.
  Campaign is then spooled in a would-be frontend aggregation table.
  """
  explainCampaign(
    """
    Type of the modification to the campaign explanation.
    """
    type: Modification!

    """
    Name of the campaign.
    """
    name: String!

    """
    Description of the campaign.
    """
    description: String!

    """
    Picture of the campaign.
    """
    picture: String

    """
    Randomly chosen seed for the creation of the identifier.
    """
    seed: Int!

    """
    Outcomes associated with this campaign. An outcome can either be something like
    Trump winning the election, or something else.
    """
    outcomes: [OutcomeInput!]!

    """
    Expected ending timestamp.
    """
    ending: Int!

    """
    Expected starting timestamp.
    """
    starting: Int!

    """
    Creator address. Hex encoded. Verified to be the creator later.
    """
    creator: String!

    """
    Oracle description defines under which conditions campaigns conclude if infra market
    used as settlement source.
    """
    oracleDescription: String

    """
    Oracle URLs are helper sources for documents when the infrastructure market is used as
    a settlement source.
    """
    oracleUrls: [String]

    """
    X/Twitter username
    """
    x: String

    """
    Telegram username
    """
    telegram: String

    """
    Web url
    """
    web: String

    """
    Should this be a fake execution as a dry run?
    """
    isFake: Boolean

  ): Boolean

  """
  Reveal a commitment, including a hash, to the server. It's okay for us to be
  permissive with the input that we accept, since a sophisticated worker will simulate
  these calls to identify the correct approach for submitting on behalf of a user. If
  a user were to spam submissions, the impact would be negligible thankfully. However,
  in those degraded scenarios where we pass 10 submissions, in the calling of this
  function, it's possible for the backend to notify the frontend that it needs to use
  revealCommitment2, which takes a signature. This will always return false,
  unless the frontend should be prompted to provide a signature.
  """
  revealCommitment(
      """
      In this highly simplified form, this is the Trading address to provide the
      commitment for. This information will be kept until the contract goes into a state
      of being able to be predicted (after the whinge is picked up on).
      """
      tradingAddr: String,

      """
      The sender's address. This is needed to simulate and then send the call. If someone
      were to abuse this permissionless process, the degraded form would be the frontend
      needing to be prompted for a signature before accepting submissions. The backend
      will deduplicate this once the time has begun.
      """
      sender: String,

      """
      The seed that's in use for this commitment. This is a large number, so this is in
      base10 as a string, which is handled with Go.
      """
      seed: String,

      """
      The preferred outcome, hex identified, preceded with 0x.
      """
      preferredOutcome: String,
  ): Boolean

  """
  The degraded form of revealCommitment, this is a version that needs to be used when
  there's an overabundance of signatures (more than 10), perhaps indicating some form of
  griefing. This should begin to be used after the server has indicated receipt of
  revealCommitment, but it's returned true. It's identical to revealCommitment, except
  gated with a signature, and will reject the user's submission unless they provide a
  correct signature. True will always be returned here.
  """
  revealCommitment2(
      """
      In this highly simplified form, this is the Trading address to provide the
      commitment for. This information will be kept until the contract goes into a state
      of being able to be predicted (after the whinge is picked up on).
      """
      tradingAddr: String,

      """
      The sender's address. This is needed to simulate and then send the call. If someone
      were to abuse this permissionless process, the degraded form would be the frontend
      needing to be prompted for a signature before accepting submissions. The backend
      will deduplicate this once the time has begun.
      """
      sender: String,

      """
      The seed that's in use for this commitment. This is a large number, so this is in
      base10 as a string, which is handled with Go.
      """
      seed: String,

      """
      The preferred outcome, hex identified, preceded with 0x.
      """
      preferredOutcome: String,

      """
      The X coordinate on the elliptic curve for the signature. Hex encoded, with the 0x
      prefix.
      """
      rr: String,

      """
      The signature proof, derived from the private key and hash of this submission
      concenated left to right. Hex encoded, with the 0x prefix.
      """
      s: String,

      """
      The recovery ID (27) for the private key used for this signature. A Int.
      """
      v: String
  ): Boolean
}

"""
Ongoing prediction market competition.
"""
type Campaign {
  """
  Name of the campaign. Also used to look up the campaign based on the slug
  if needed (hyphenated).
  """
  name: String!

  """
  Description of the campaign in simple text.
  """
  description: String!

  """
  Picture of the campaign.
  """
  picture: String

  """
  Creator of the campaign.
  """
  creator: Wallet!

  """
  Timestamp of the creation of the creation of this campaign (specifically, when it was
  included).
  """
  createdAt: Int!

  """
  Defines the method used to determine the winner of a campaign.
  """
  settlement: SettlementType!

  """
  Oracle description defines under which conditions campaigns conclude
  """
  oracleDescription: String

  """
  Oracle URLs are helper sources for documents when the infrastructure market is used as a settlement source.
  """
  oracleUrls: [String]

  """
  Identifier that's used to do offline derivation of the campaign pool,
  and the outcome shares. Is keccak256(concatenated outcome ids)[:8].
  """
  identifier: String!

  """
  Pool address to purchase shares, and to receive the cost function.
  """
  poolAddress: String!

  """
  Outcomes associated with this campaign. If there are only two, it defaults
  to a "yes", or "no".
  """
  outcomes: [Outcome!]!

  """
  Expected starting timestamp.
  """
  starting: Int!,

  """
  Ending date of the campaign in timestamp
  """
  ending: Int!

  """
  X/Twitter username
  """
  x: String

  """
  Telegram username
  """
  telegram: String

  """
  Web url
  """
  web: String

  """
  If any outcome declared as winner, it returns bytes8 id
  """
  winner: String

  """
  It returns total invested amount as usd
  """
  totalVolume: Int!

  """
  Represents investment results bytes8 ids to amounts.
  """
  investmentAmounts: [InvestmentAmounts]!

  """
  Any moderator sent banners notifying people of a change in this market.
  """
  banners: [String!]!

  """
  Campaigns can be tagged with multiple categories
  """
  categories: [String!]!
}

type InvestmentAmounts {
  """
  outcome id bytes8
  """
  id: String!

  """
  6 decimals fusdc
  """
  usdc: Int!

  """
  6 decimals share
  """
  share: Int!
}

type Outcome {

  """
  Name of this campaign.
  """
  name: String!


  """
  Picture of the outcome.
  """
  picture: String

  """
  Identifier hex encoded associated with this outcome. Used to derive addresses.
  Is of the form keccak256("o" . name . "d" . description . "s" . seed)[:8]
  """
  identifier: String!

  """
  Share address to trade this outcome.
  """
  share: Share!
}

"""
Wallet of the creator.
"""
type Wallet {
  """
  Wallet address of this wallet, in hex.
  """
  address: String!
}

"""
Share representing the outcome of the current amount.
"""
type Share {
  """
  ERC20 address of this campaign.
  """
  address: String!
}

"""
HTTP-like interface for mutation. Either a delete, a logical update, or a put for the
first time.
"""
enum Modification {
  """
  Delete this modification.
  """
  DELETE,

  """
  Create this modification.
  """
  PUT
}

"""
News that could be rendered to a viewer who hasn't viewed the site in a while.
This is CHANGELOG.md that's parsed to be of the form:
```
### (date) (description)

* Markdown unsorted list

1. Markdown sorted list

... yadda yadda
```

This is converted to HTML.
"""
type Changelog {
    id: ID!

    """
    The title of the changelog item.
    """
    title: String!

    """
    The timestamp that this item is relevant for after.
    """
    afterTs: Int!

    """
    HTML rendered from the Markdown CHANGELOG.md file.
    """
    html: String!
}

"""
Defines the method used to determine the winner of a campaign.
"""
enum SettlementType {
  """
  Infrastructure market.
  """
  ORACLE,

  """
  Opinion Poll.
  """
  POLL

  """
  A.I Resolver.
  """
  AI

  """
  Contract State.
  """
  CONTRACT
}

"""
Represents the type of an activity.
"""
enum ActivityType {
  buy,
  sell
}

"""
Represents a buy or sell activity.
"""
type Activity {
  """
  Transaction hash of the activity.
  """
  txHash: String!
  
  """
  Address of the recipient involved in the activity.
  """
  recipient: String!

  """
  Pool address associated with the activity.
  """
  poolAddress: String!

  """
  Amount of the asset being transferred from.
  """
  fromAmount: Int!

  """
  Symbol of the asset being transferred from.
  """
  fromSymbol: String!

  """
  Amount of the asset being transferred to.
  """
  toAmount: Int!

  """
  Symbol of the asset being transferred to.
  """
  toSymbol: String!

  """
  Type of the activity (buy, sell).
  """
  type: ActivityType!

  """
  ID of the outcome associated with the activity.
  """
  outcomeId: String!

  """
  Name of the outcome associated with the activity.
  """
  outcomeName: String!

  """
  Picture of the outcome associated with the activity.
  """
  outcomePic: String

  """
  Name of the campaign associated with the activity.
  """
  campaignName: String!

  """
  ID of the campaign associated with the activity.
  """
  campaignId: String!

  """
  Total volume of the activity.
  """
  totalVolume: Int!

  """
  Timestamp of when the activity was created.
  """
  createdAt: Int!
}
